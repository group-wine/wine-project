---
title: "sommelieR"
author: "Seoyoon Cho, Paloma Hauser, Taylor Lagler, Mike Nodzenski, Bryce Rowland"
date: "4/10/2019"
output: 
  beamer_presentation:
    color: "seahorse"
header-includes:
- \usepackage{booktabs}
- \usepackage{longtable}
- \usepackage{array}
- \usepackage{multirow}
- \usepackage{wrapfig}
- \usepackage{float}
- \usepackage{colortbl}
- \usepackage{pdflscape}
- \usepackage{tabu}
- \usepackage{threeparttable}
---

```{r libraries, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

# create the datasets for training and testing for the group project
set.seed(13)

library(caret)
library(readr)
library(dplyr)
library(ggplot2)
library(data.table)
library(gridExtra)
library(Hmisc)
library(corrplot)
library(tidyverse)
library(kableExtra)
library(knitr)
library(devtools)

#install sommelieR
install_github("group-wine/sommelieR")
library(sommelieR)
```

```{r setup, include = F}
#load the datasets 
data("red_test")
data("red_train")
data("white_test")
data("white_train")
white.obs <- white_test$quality
red.obs <- red_test$quality


# Data splitting and merging scripts can be found in Data folder

#--------------------------------------------------------------------#
# Data set up for boxplot code:
red_all =  fread("./data/winequality-red.csv",header=T)
red_all$quality <- as.factor(red_all$quality)
names(red_all) = gsub(" ", "_", names(red_all))

white_all =  fread("./data/winequality-white.csv",header=T)
white_all$quality <- as.factor(white_all$quality)
names(white_all) = gsub(" ", "_", names(white_all))

#--------------------------------------------------------------------#
# Data set up for RF classification by type code:
all_train = fread("./data/training_data/all_train.csv",header=T)
all_test = fread("./data/testing_data/all_test.csv",header=T)

x.train = as.data.frame(all_train[,1:11], ncol=11)
y.train = factor(all_train$type)

x.test = as.data.frame(all_test[,1:11], ncol=11)
y.test = factor(all_test$type)

#--------------------------------------------------------------------#
# Data set up for RF classification by quality code:
source("./R/cmPlot_function.R") # required to plot CMs

# red_train = fread("./data/training_data/red_train.csv",header=T)
# red_test = fread("./data/testing_data/red_test.csv",header=T)
# 
# white_train = fread("./data/training_data/white_train.csv",header=T)
# white_test = fread("./data/testing_data/white_test.csv",header=T)

x.train.red = as.data.frame(red_train[,1:11], ncol=11)
y.train.red = factor(red_train$quality)

x.test.red = as.data.frame(red_test[,1:11], ncol=11)
y.test.red = factor(red_test$quality)

x.train.white = as.data.frame(white_train[,1:11], ncol=11)
y.train.white = factor(white_train$quality)

x.test.white = as.data.frame(white_test[,1:11], ncol=11)
y.test.white = factor(white_test$quality)

# group into low (3-4), mid (5-6) and high (7-9)
y.train.red.grp <- y.train.red
levels(y.train.red.grp)[1:2] <- "low"
levels(y.train.red.grp)[2:3] <- "mid"
levels(y.train.red.grp)[3:4] <- "high"

y.test.red.grp <- y.test.red
levels(y.test.red.grp)[1:2] <- "low"
levels(y.test.red.grp)[2:3] <- "mid"
levels(y.test.red.grp)[3:4] <- "high"

y.train.white.grp <- y.train.white
levels(y.train.white.grp)[1:2] <- "low"
levels(y.train.white.grp)[2:3] <- "mid"
levels(y.train.white.grp)[3:5] <- "high"

y.test.white.grp <- y.test.white
levels(y.test.white.grp)[1:2] <- "low"
levels(y.test.white.grp)[2:3] <- "mid"
levels(y.test.white.grp)[3:5] <- "high"

#--------------------------------------------------------------------#


```

## Introduction
* 2 datasets related to red and white Vinho Verde wines
* each contain 11 physiochemical variables
    + fixed acidity, volatile acidity, citric acid, residual sugar, chlorides, free sulfur dioxide, total sulfur dioxide, density, pH, sulphates, alcohol
* 6,493 observations
* outcome variable: wine quality
    + ordinal variable ranging from 0-10
    + 0 is poor, 10 is excellent 
    + classes are unbalanced

## Project Aim
Is it possible to predict wine quality using some subset of the physiochemical variables?

## Looking At the Red Wine Data
```{r red.boxplots, echo=FALSE, warning=FALSE}
# red wine
grid.arrange(
  ggplot(red_all, aes(x = quality, y = fixed_acidity)) +
    geom_boxplot()+geom_jitter(alpha = .25),
  ggplot(red_all, aes(x = quality, y = volatile_acidity)) +
    geom_boxplot()+geom_jitter(alpha = .25),
  ggplot(red_all, aes(x = quality, y = citric_acid)) +
    geom_boxplot()+geom_jitter(alpha = .25),
  ggplot(red_all, aes(x = quality, y = residual_sugar)) +
    geom_boxplot()+geom_jitter(alpha = .25),
  ggplot(red_all, aes(x = quality, y = chlorides)) +
    geom_boxplot()+geom_jitter(alpha = .25),
  ggplot(red_all, aes(x = quality, y = free_sulfur_dioxide)) +
    geom_boxplot()+geom_jitter(alpha = .25),
  ggplot(red_all, aes(x = quality, y = total_sulfur_dioxide)) +
    geom_boxplot()+geom_jitter(alpha = .25),
  ggplot(red_all, aes(x = quality, y = density)) +
    geom_boxplot()+geom_jitter(alpha = .25),
  ggplot(red_all, aes(x = quality, y = pH)) +
    geom_boxplot()+geom_jitter(alpha = .25),
  ggplot(red_all, aes(x = quality, y = sulphates)) +
    geom_boxplot()+geom_jitter(alpha = .25),
  ggplot(red_all, aes(x = quality, y = alcohol)) +
    geom_boxplot()+geom_jitter(alpha = .25), ncol=4
)
```

## Looking At the White Wine Data
```{r white.boxplots, echo=FALSE, warning=FALSE}
# white wine
grid.arrange(
  ggplot(white_all, aes(x = quality, y = fixed_acidity)) +
    geom_boxplot()+geom_jitter(alpha = .25),
  ggplot(white_all, aes(x = quality, y = volatile_acidity)) +
    geom_boxplot()+geom_jitter(alpha = .25),
  ggplot(white_all, aes(x = quality, y = citric_acid)) +
    geom_boxplot()+geom_jitter(alpha = .25),
  ggplot(white_all, aes(x = quality, y = residual_sugar)) +
    geom_boxplot()+geom_jitter(alpha = .25),
  ggplot(white_all, aes(x = quality, y = chlorides)) +
    geom_boxplot()+geom_jitter(alpha = .25),
  ggplot(white_all, aes(x = quality, y = free_sulfur_dioxide)) +
    geom_boxplot()+geom_jitter(alpha = .25),
  ggplot(white_all, aes(x = quality, y = total_sulfur_dioxide)) +
    geom_boxplot()+geom_jitter(alpha = .25),
  ggplot(white_all, aes(x = quality, y = density)) +
    geom_boxplot()+geom_jitter(alpha = .25),
  ggplot(white_all, aes(x = quality, y = pH)) +
    geom_boxplot()+geom_jitter(alpha = .25),
  ggplot(white_all, aes(x = quality, y = sulphates)) +
    geom_boxplot()+geom_jitter(alpha = .25),
  ggplot(white_all, aes(x = quality, y = alcohol)) +
    geom_boxplot()+geom_jitter(alpha = .25), ncol=4
)
```

## Correlations- Red Wine
```{r red.correlations, echo=FALSE, fig.align='center', message=FALSE, warning=FALSE}
# correlations and p-values by variable pairs
rcor_red <-rcorr(as.matrix(red_all[,1:11]))

# plot of correlations
corrplot(rcor_red$r, type="upper", order="hclust", tl.col = "black",
         p.mat = rcor_red$P, sig.level = 0.01, insig = "blank")
```

## Correlations- White Wine
```{r white.correlations, echo=FALSE, fig.align='center', message=FALSE, warning=FALSE}
# correlations and p-values by variable pairs
rcor_white <-rcorr(as.matrix(white_all[,1:11]))

# plot of correlations
corrplot(rcor_white$r, type="upper", order="hclust", tl.col = "black",
         p.mat = rcor_white$P, sig.level = 0.01, insig = "blank")
```

## Methods
* linear model
* partial proportional odds model
* multinomial model
* random forests

## Variable Selection
For variable selection, we examined the correlations between predictors and considered best subsets found in R. For the likelihood based models, we included the following predictors:
  
  * red wine: volatile acidity, total sulfur dioxide, pH, alcohol, sulphates
* white wine: pH, density, volatile_acidity, residual_sugar, alcohol

## Results: Linear Model

## Results: Partial Proportional Odds Model (White Wine)

* Non-proportional odds: $logit(P(Z \leq j|x)) = \alpha_j + x^T\beta_j$
* Proportional odds: $logit(P(Z \leq j|x)) = \alpha_j + x^T\beta$
* Partial proportional odds: $logit(P(Z \leq j|x)) = \alpha_j + x^T_*\beta + x^T_{**}\beta_j$ 

```{r}
library(psych)
beta.starts <- coef(lm(quality ~ alcohol+ pH + volatile.acidity + residual.sugar,
                       data = white_train))

#fully proportional odds 
white.prop.odds <- partial.prop.odds.mod(y ="quality", in.data = white_train,
                              prop.odds.formula = ~ alcohol+ pH + volatile.acidity + residual.sugar,
                              beta.prop.odds.start = beta.starts[c(2:5)],
                              method = "BFGS")
white.preds <- predict(white.prop.odds, white_test)$most.likely

#compare to actual values  
white.pred.table <- data.frame(table(factor(white.preds, levels = sort(unique(white.obs))), white.obs))
white.pred.table$Freq[white.pred.table$Freq == 0] <- NA
white.pred.accuracy <- sum(white.preds == white.obs)/length(white.obs)
white.pred.kappa <- cohen.kappa(cbind(white.preds, white.obs))$kappa
white.pred.wkappa <- cohen.kappa(cbind(white.preds, white.obs))$weighted.kappa

```

* Only proportional odds model converged 
* Overall Accuracy: `r round(100*white.pred.accuracy, 2)`%
* Kappa: `r round(100*white.pred.kappa, 2)`
* Weighted Kappa: `r round(100*white.pred.wkappa, 2)`

```{r}
#plotting confusion matrix 
cmPlot(white.pred.table, "white", pred_first = T, title = "Proportional Odds Model Predicted vs Observed")

```

## Results: Partial Proportional Odds Model (Red Wine)

* Proportional, partial proportional, and and non-proportional odds models all converged
* Results presented for partial proportional model with coefficient for total sulfur dioxide allowed to vary with the level of wine quality

```{r}

beta.starts <- coef(lm(quality ~ alcohol+ pH + volatile.acidity + sulphates + total.sulfur.dioxide,
                       data = red_train))

#partial proportional odds model
red.partial.prop <- partial.prop.odds.mod(y ="quality", in.data = red_train,
                              prop.odds.formula = ~ alcohol + pH+ volatile.acidity + sulphates,
                              beta.prop.odds.start = beta.starts[2:5],
                              non.prop.odds.formula = ~total.sulfur.dioxide,
                              beta.non.prop.odds.start = matrix(rep(beta.starts[6], 5), nrow = 1),
                              method = "BFGS")
red.partial.prop.preds <- predict(red.partial.prop, red_test)$most.likely
table(factor(red.partial.prop.preds, levels = sort(unique(red.obs))), red.obs)
red.partial.prop.accuracy <- sum(red.partial.prop.preds == red.obs)/length(red.obs)
red.partial.prop.accuracy
red.partial.prop.kappa <- cohen.kappa(cbind(red.partial.prop.preds, red.obs))$kappa
red.partial.prop.wkappa <- cohen.kappa(cbind(red.partial.prop.preds, red.obs))$weighted.kappa

#proportional odds model
red.prop.odds <- partial.prop.odds.mod(y ="quality", in.data = red_train,
                              prop.odds.formula = ~ alcohol + pH + volatile.acidity + sulphates
                              + total.sulfur.dioxide,
                              beta.prop.odds.start = beta.starts[2:6],
                              method = "BFGS")
red.prop.odds.preds <- predict(red.prop.odds, red_test)$most.likely

red.prop.odds.table <- data.frame(table(factor(red.prop.odds.preds, levels = sort(unique(red.obs))), red.obs))
red.prop.odds.table$Freq[red.prop.odds.table$Freq == 0] <- NA
red.prop.odds.accuracy <- sum(red.prop.odds.preds == red.obs)/length(red.obs)
red.prop.odds.kappa <- cohen.kappa(cbind(red.prop.odds.preds, red.obs))$kappa
red.prop.odds.wkappa <- cohen.kappa(cbind(red.prop.odds.preds, red.obs))$weighted.kappa

#all non-proportional 
red.non.prop <- partial.prop.odds.mod(y ="quality", in.data = red_train,
                              non.prop.odds.formula = ~ alcohol + pH+ volatile.acidity + sulphates
                              + total.sulfur.dioxide,
                              beta.non.prop.odds.start = matrix(rep(beta.starts[2:6], each = 5), nrow = 5, 
                                                                byrow = T),
                              method = "BFGS")
red.non.prop.preds <- predict(red.non.prop, red_test)$most.likely
red.non.prop.accuracy <- sum(red.non.prop.preds == red.obs)/length(red.obs)
red.non.prop.kappa <- cohen.kappa(cbind(red.non.prop.preds, red.obs))$kappa
red.non.prop.wkappa <- cohen.kappa(cbind(red.non.prop.preds, red.obs))$weighted.kappa
red.non.prop.odds.table <- data.frame(table(factor(red.non.prop.preds, levels = sort(unique(red.obs))), red.obs))
red.non.prop.odds.table$Freq[red.non.prop.odds.table$Freq == 0] <- NA

#comparison of methods 
red.partial.prop.model.comp <- data.frame(Model = c("Proportional Odds", "Partial Proportional Odds",
                                                    "Non-Proportional Odds"), 
                                          Accuracy = c(red.prop.odds.accuracy, red.partial.prop.accuracy, 
                                                       red.non.prop.accuracy), 
                                          Kappa = c(red.prop.odds.kappa, red.partial.prop.kappa, 
                                                       red.non.prop.kappa),
                                          Weighted.Kappa = c(red.prop.odds.wkappa, red.partial.prop.wkappa, 
                                                       red.non.prop.wkappa)) 
colnames(red.partial.prop.model.comp) <- c("Model", "Accuracy", "Kappa", "Weighted Kappa")
kable(red.partial.prop.model.comp, caption = "Comparison of Partial Proportional Odds Models for Red Wine Quality",
      digits = 4, booktabs=T)
```

* Results are similar across models 
* Overall Accuracy is best for non-proportional odds
* Weighted kappa best for proportional odds model 

```{r}
#plotting confusion matrix 
cmPlot(red.prop.odds.table, "red", pred_first = T, title = "Proportional Odds Predicted vs Observed")
cmPlot(red.non.prop.odds.table, "red", pred_first = T, title = "Non-Proportional Odds Predicted vs Observed")

```


## Results: Multinomial Model

```{r}
red_test_fit <- fit_multinomial_regression(red_test, quality ~ 1 + alcohol + volatile.acidity + total.sulfur.dioxide + pH + sulphates, ref_level = "8", trace = 1, itters = 300)
```



## Results: Random Forests (wine type classification)
```{r merged.rf, fig.align='center', echo=FALSE, message=FALSE, warning=FALSE}
# train random forest
trCtl <- trainControl(savePredictions=TRUE)
fit <- train(x.train, y.train, method="rf", trControl=trCtl)

# random forest training results
#fit$results

# use training model to predict y
y.pred <- predict(fit, x.test)

# results of rf on test data
cM = confusionMatrix(data=y.pred, reference=y.test)

# classification results (red vs white)
#cM$table
pred <- round(cM$overall[1:2], 4) # prediction accuracy and kappa
res <- round(diag(cM$table)/table(y.test), 4)*100 # percent correct into each type

results.type <- setNames(data.frame(matrix(ncol = 4, nrow = 1)),
                            c("Prediction Accuracy", "Kappa", "Red", "White"))
results.type[1,] <- c(pred,res)
rownames(results.type) = c("Random Forest")

kable(results.type, caption = "Classification Results for Wine Type", booktabs=T) %>%
  add_header_above(c(" ", "Overall Results" = 2, "Percent Correct by Category" = 2)) %>%
  kable_styling(latex_options = c("repeat_header", "scale_down"))
```

## Results: Random Forests (wine type classification)
```{r merged.rfplot, fig.align='center', echo=FALSE, message=FALSE, warning=FALSE}
# classification results as a plot
class.table <- as.data.frame(cM$table)
class.table$Freq[class.table$Freq == 0] <-NA
ggplot(class.table, aes(x = Reference, y = Prediction, size = Freq, fill=Freq, label=Freq)) +
  scale_size(range=c(8,30)) + geom_label(na.rm=T) + theme_minimal() +
  scale_fill_continuous(low="red3", high="lightyellow") + guides(size=FALSE) +
  ggtitle("RF Classification of Wine Type") + theme(plot.title = element_text(hjust=.5, size=20))
```


## Results: Random Forests (red wine quality classification)
```{r red.rf, fig.align='center', echo=FALSE, message=FALSE, warning=FALSE}
source("./R/cmPlot_function.R") # required to plot CMs
# train random forest
trCtl <- trainControl(savePredictions=TRUE)
fit.red <- train(x.train.red, y.train.red, method="rf", trControl=trCtl)
fit.white <- train(x.train.white, y.train.white, method="rf", trControl=trCtl)

# random forest training results
#fit.red$results
#fit.white$results

# use training model to predict y
y.pred.red <- predict(fit.red, x.test.red)
y.pred.white <- predict(fit.white, x.test.white)

# results of rf on test data
cM.red = confusionMatrix(data=y.pred.red, reference=y.test.red)
cM.white = confusionMatrix(data=y.pred.white, reference=y.test.white)

# classification results (into quality score)
#cM.red$table
class.red <- as.data.frame(cM.red$table)
class.red$Freq[class.red$Freq == 0] <-NA

#cM.white$table
class.white <- as.data.frame(cM.white$table)
class.white$Freq[class.white$Freq == 0] <-NA

# classification results as a plot
cmPlot(class.red, "red", pred_first = TRUE,
"RF Classification of Quality for Red Wines")
#cmPlot(class.white, "white", pred_first = TRUE,
#       "RF Classification of Quality for White Wines")

# prediction accuracy by category
pred.red <- round(diag(cM.red$table)/table(y.test.red), 4)*100
pred.white <- round(diag(cM.white$table)/table(y.test.white), 4)*100

# prediction accuracy and kappa
res.red = round(cM.red$overall[1:2], 4)
res.red[1] = res.red[1]*100
res.white = round(cM.white$overall[1:2], 4) 
res.white[1] = res.white[1]*100

# weighted kappas
wk.red <- round(cohen.kappa(cM.red$table)$weighted.kappa, 4)
wk.white <- round(cohen.kappa(cM.white$table)$weighted.kappa, 4)
```

## Results: Random Forests (white wine quality classification)
```{r white.rf, fig.align='center', echo=FALSE, message=FALSE, warning=FALSE}
cmPlot(class.white, "white", pred_first = TRUE,
"RF Classification of Quality for White Wines")
```

## Results: Random Forests (grouped red wine quality classification)
```{r red.rf.grouped, fig.align='center', echo=FALSE, message=FALSE, warning=FALSE}
# train random forest
fit.red.grp <- train(x.train.red, y.train.red.grp, method="rf", trControl=trCtl)
fit.white.grp <- train(x.train.white, y.train.white.grp, method="rf", trControl=trCtl)

# random forest training results
#fit.red.grp$results
#fit.white.grp$results

# use training model to predict y
y.pred.red.grp <- predict(fit.red.grp, x.test.red)
y.pred.white.grp <- predict(fit.white.grp, x.test.white)

# results of rf on test data
cM.red.grp = confusionMatrix(data=y.pred.red.grp, reference=y.test.red.grp)
cM.white.grp = confusionMatrix(data=y.pred.white.grp, reference=y.test.white.grp)

# classification results (into quality score)
#cM.red.grp$table
class.red.grp <- as.data.frame(cM.red.grp$table)
class.red.grp$Freq[class.red.grp$Freq == 0] <-NA

#cM.white.grp$table
class.white.grp <- as.data.frame(cM.white.grp$table)
class.white.grp$Freq[class.white.grp$Freq == 0] <-NA

# classification results as a plot
cmPlot(class.red.grp, "red", pred_first = TRUE,
"RF Classification of Grouped Quality for Red Wines")
#cmPlot(class.white.grp, "white", pred_first = TRUE,
#       "RF Classification of Grouped Quality for White Wines")

# prediction accuracy by category
pred.red.grp <- round(diag(cM.red.grp$table)/table(y.test.red.grp), 4)*100
pred.white.grp <- round(diag(cM.white.grp$table)/table(y.test.white.grp), 4)*100

# prediction accuracy and kappa
res.red.grp = round(cM.red.grp$overall[1:2], 4)
res.red.grp[1] = res.red.grp[1]*100
res.white.grp = round(cM.white.grp$overall[1:2], 4)
res.white.grp[1] = res.white.grp[1]*100

# weighted kappas
wk.red.grp <- round(cohen.kappa(cM.red.grp$table)$weighted.kappa, 4)
wk.white.grp <- round(cohen.kappa(cM.white.grp$table)$weighted.kappa, 4)
```
## Results: Random Forests (grouped white wine quality classification)
```{r white.rf.grouped,echo=FALSE, message=FALSE, warning=FALSE}
cmPlot(class.white.grp, "white", pred_first = TRUE,
"RF Classification of Grouped Quality for White Wines")
```

## Results: Random Forests with Subsampling (grouped red wine quality classification)
```{r red.rf.grouped.ss,echo=FALSE, message=FALSE, warning=FALSE}
# subsmaple training data based on minimum within group count
train.red.grp <- cbind(x.train.red, y.train.red.grp)
ns.red <- min(table(train.red.grp$y.train.red.grp))
train.red.grp.ss <- train.red.grp %>% group_by(y.train.red.grp) %>% sample_n(ns.red)
x.train.red.grp.ss <- as.data.frame(train.red.grp.ss[,1:11], ncol=11)
y.train.red.grp.ss <- factor(train.red.grp.ss$y.train.red.grp)

train.white.grp <- cbind(x.train.white, y.train.white.grp)
ns.white <- min(table(train.white.grp$y.train.white.grp))
train.white.grp.ss <- train.white.grp %>% group_by(y.train.white.grp) %>% sample_n(ns.white)
x.train.white.grp.ss <- as.data.frame(train.white.grp.ss[,1:11], ncol=11)
y.train.white.grp.ss <- factor(train.white.grp.ss$y.train.white.grp)

# train random forest
fit.red.grp.ss <- train(x.train.red.grp.ss, y.train.red.grp.ss, method="rf", trControl=trCtl)
fit.white.grp.ss <- train(x.train.white.grp.ss, y.train.white.grp.ss, method="rf", trControl=trCtl)

# random forest training results
#fit.red.grp.ss$results
#fit.white.grp.ss$results

# use training model to predict y
y.pred.red.grp.ss <- predict(fit.red.grp.ss, x.test.red)
y.pred.white.grp.ss <- predict(fit.white.grp.ss, x.test.white)

# results of rf on test data
cM.red.grp.ss <- confusionMatrix(data=y.pred.red.grp.ss, reference=y.test.red.grp)
cM.white.grp.ss <- confusionMatrix(data=y.pred.white.grp.ss, reference=y.test.white.grp)

# classification results (into quality score)
#cM.red.grp.ss$table
class.red.grp.ss <- as.data.frame(cM.red.grp.ss$table)
class.red.grp.ss$Freq[class.red.grp.ss$Freq == 0] <-NA

#cM.white.grp.ss$table
class.white.grp.ss <- as.data.frame(cM.white.grp.ss$table)
class.white.grp.ss$Freq[class.white.grp.ss$Freq == 0] <-NA

# classification results as a plot
cmPlot(class.red.grp.ss, "red", pred_first = TRUE,
"RF Classification of Grouped Quality for Red Wines \n Subsampled by Group")
# cmPlot(class.white.grp.ss, "white", pred_first = TRUE,
#        "RF Classification of Grouped Quality for White Wines \n Subsampled by Group")

# prediction accuracy by category
pred.red.grp.ss <- round(diag(cM.red.grp.ss$table)/table(y.test.red.grp), 4)*100
pred.white.grp.ss <- round(diag(cM.white.grp.ss$table)/table(y.test.white.grp), 4)*100

# prediction accuracy and kappa
res.red.grp.ss <- round(cM.red.grp.ss$overall[1:2],4)
res.red.grp.ss[1] = res.red.grp.ss[1]*100
res.white.grp.ss <- round(cM.white.grp.ss$overall[1:2],4)
res.white.grp.ss[1] = res.white.grp.ss[1]*100

# weighted kappas
wk.red.grp.ss <- round(cohen.kappa(cM.red.grp.ss$table)$weighted.kappa, 4)
wk.white.grp.ss <- round(cohen.kappa(cM.white.grp.ss$table)$weighted.kappa, 4)

```

## Results: Random Forests with Subsampling (grouped red wine quality classification)

```{r white.rf.grouped.ss,echo=FALSE, message=FALSE, warning=FALSE}
cmPlot(class.white.grp.ss, "white", pred_first = TRUE,
"RF Classification of Grouped Quality for White Wines \n Subsampled by Group")
```

## Comparison of Results: Red Wine, Ungrouped
```{r echo=FALSE, message=FALSE, warning=FALSE}
#-----------------------------------------------------------------------------#
#-----------------------------------------------------------------------------#
# Create Results Data Tables
# round results to 4 digits
# accuracy into categories as percent
# rename row and fill in data accordingly (add more rows if needed)
library(knitr)
library(kableExtra)
#-----------------------------------------------------------------------------#
# RED WINE NO GROUPING
results.red <- setNames(data.frame(matrix(ncol = 9, nrow = 4)),
c("Prediction Accuracy", "Kappa", "Weighted Kappa", "3", "4", "5", "6", "7", "8"))
rownames(results.red) <- c("Random Forest", "Method 2", "Method 3", "Method 4")

results.red[1,] <- c(res.red, pred.red, wk.red)


#-----------------------------------------------------------------------------#
# WHITE WINE NO GROUPING
results.white <- setNames(data.frame(matrix(ncol = 10, nrow = 4)),
c("Prediction Accuracy", "Kappa", "Weighted Kappa", "3", "4", "5", "6", "7", "8", "9"))
rownames(results.white) <- c("Random Forest", "Method 2", "Method 3", "Method 4")

results.white[1,] <- c(res.white, pred.white, wk.white)


#-----------------------------------------------------------------------------#
# RED WINE WITH GROUPING
results.red.grp <- setNames(data.frame(matrix(ncol = 6, nrow = 5)),
c("Prediction Accuracy", "Kappa", "Weighted Kappa", "Low", "Mid", "High"))
rownames(results.red.grp) <- c("Random Forest", "RF Subsampled",
"Method 3", "Method 4", "Method 5")

results.red.grp[1,] <- c(res.red.grp, pred.red.grp, wk.red.grp)
results.red.grp[2,] <- c(res.red.grp.ss, pred.red.grp.ss, wk.red.grp.ss)


#-----------------------------------------------------------------------------#
# WHITE WINE WITH GROUPING
results.white.grp <- setNames(data.frame(matrix(ncol = 6, nrow = 5)),
c("Prediction Accuracy", "Kappa", "Weighted Kappa", "Low", "Mid", "High"))
rownames(results.white.grp) <- c("Random Forest", "RF Subsampled",
"Method 3", "Method 4", "Method 5")

results.white.grp[1,] <- c(res.white.grp, pred.white.grp, wk.white.grp)
results.white.grp[2,] <- c(res.white.grp.ss, pred.white.grp.ss, wk.white.grp.ss)

#-----------------------------------------------------------------------------#
# Print out comparison tables created above
# Red wine no groups
kable(results.red, caption = "Comparison of Results for Red Wine", booktabs=T) %>%
add_header_above(c(" ", "Overall Results" = 3, "Percent Correct by Category" = 6)) %>%
kable_styling(latex_options = c("repeat_header", "scale_down"))

#-----------------------------------------------------------------------------#
```

## Comparison of Results: White Wine, Ungrouped
```{r echo=FALSE, message=FALSE, warning=FALSE}
# Print out comparison tables created above

# White wine no groups
kable(results.white, caption = "Comparison of Results for White Wine", booktabs=T) %>%
add_header_above(c(" ", "Overall Results" = 3, "Percent Correct by Category" = 7)) %>%
kable_styling(latex_options = c("repeat_header", "scale_down"))
```

## Comparison of Results: Red Wine, Grouped
```{r echo=FALSE, message=FALSE, warning=FALSE}
# Red wine grouped
kable(results.red.grp, caption = "Comparison of Results for Red Wine with Grouped Quality", booktabs=T) %>%
add_header_above(c(" ", "Overall Results" = 3, "Percent Correct by Category" = 3)) %>%
kable_styling(latex_options = c("repeat_header", "scale_down"))
```

## Comparison of Results: White Wine, Grouped
```{r echo=FALSE, message=FALSE, warning=FALSE}
# White wine grouped
kable(results.white.grp, caption = "Comparison of Results for White Wine with Grouped Quality", booktabs=T) %>%
add_header_above(c(" ", "Overall Results" = 3, "Percent Correct by Category" = 3)) %>%
kable_styling(latex_options = c("repeat_header", "scale_down"))
```

## Discussion   
(about interpretation or possible future directions) 




